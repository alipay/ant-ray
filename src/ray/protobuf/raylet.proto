syntax = "proto3";

import "gcs.proto";

package ray.rpc;


// Data structure.
message ResourceIdSetInfo {
  // The name of the resource.
  bytes resource_name = 1;
  // The resource IDs reserved for this worker.
  repeated uint64 resource_ids = 2;
  // The fraction of each resource ID that is reserved for this worker. Note
  // that the length of this list must be the same as the length of
  // resource_ids.
  repeated double resource_fractions = 3;
}

// Service request message.
message SubmitTaskRequest {
  repeated bytes execution_dependencies = 1;
  bytes task_spec = 2;
}

message TaskDoneRequest {
}

message EventLogRequest {
}

message RegisterClientRequest {
  // True if the client is a worker and false if the client is a driver.
  bool is_worker = 1;
  // The ID of this raylet client.
  // Worker id is same as client id if the client is a worker.
  bytes client_id = 2;
  // The process ID of this worker.
  uint32 worker_pid = 3;
  // The driver ID. This is non-nil if the client is a driver.
  bytes driver_id = 4;
  // Language of this worker.
  Language language = 5;
}

message DisconnectClientRequest {
}

message IntentionalDisconnectClientRequest {
}

message GetTaskRequest {
}

message ExecuteTaskRequest {
}
message FetchOrReconstructRequest {
}
message NotifyUnblockedRequest {
}
message GetActorFrontierRequest {
}
message SetActorFrontierRequest {
}
message WaitRequest{
}
message PushErrorRequest {
}
message PushProfileEventsRequest {
}
message FreeObjectsInObjectStoreRequest {
}
message PrepareActorCheckpointRequest {
}
message NotifyActorResumedFromCheckpointRequest {
}
message SetResourceRequest {
}

// Service reply.
message SubmitTaskReply {
}
message TaskDoneReply {
}
message EventLogReply {
}
message RegisterClientReply {
  repeated int32 gpu_ids = 1;
}
message DisconnectClientReply {
}
message IntentionalDisconnectClientReply {
}
message GetTaskReply {
  // A string of bytes representing the task specification.
  bytes task_spec = 1;
  // A list of the resources reserved for this worker.
  repeated ResourceIdSetInfo fractional_resource_ids = 2;
}
message ExecuteTaskReply {
}
message FetchOrReconstructReply {
}
message NotifyUnblockedReply {
}
message GetActorFrontierReply {
}
message SetActorFrontierReply {
}
message WaitReply{
}
message PushErrorReply {
}
message PushProfileEventsReply {
}
message FreeObjectsInObjectStoreReply {
}
message PrepareActorCheckpointReply {
}
message NotifyActorResumedFromCheckpointReply {
}
message SetResourceReply {
}


// Service interface.
service RayletService {
  // This struct is used to register a new worker with the raylet.
  rpc RegisterClient(RegisterClientRequest) returns (RegisterClientReply);
  // Task is submitted to the raylet. This is sent from a worker to a
  // raylet.
  rpc SubmitTask(SubmitTaskRequest) returns (SubmitTaskReply);
  // Notify the raylet that a task has finished. This is sent from a
  // worker to a raylet.
  rpc TaskDone(TaskDoneRequest) returns (TaskDoneReply);
  // Log a message to the event table. This is sent from a worker to a raylet.
  rpc EventLog(EventLogRequest) returns (EventLogReply);
  // Notify the raylet that this client is disconnecting unexpectedly.
  // This is sent from a worker to a raylet.
  rpc DisconnectClient(DisconnectClientRequest) returns (DisconnectClientReply);
  // Notify the raylet that this client is disconnecting gracefully.
  // This is sent from a worker to a raylet.
  rpc IntentionalDisconnectClient(IntentionalDisconnectClientRequest) returns (IntentionalDisconnectClientReply);
  // Get a new task from the raylet. This is sent from a worker to a
  // raylet.
  rpc GetTask(GetTaskRequest) returns (GetTaskReply);
  // Tell a worker to execute a task. This is sent from a raylet to a
  // worker.
  rpc ExecuteTask(ExecuteTaskRequest) returns (ExecuteTaskReply);
  // Reconstruct or fetch possibly lost objects. This is sent from a worker to
  // a raylet.
  rpc FetchOrReconstruct(FetchOrReconstructRequest) returns (FetchOrReconstructReply);
  // For a worker that was blocked on some object(s), tell the raylet
  // that the worker is now unblocked. This is sent from a worker to a raylet.
  rpc NotifyUnblocked(NotifyUnblockedRequest) returns (NotifyUnblockedReply);
  // A request to get the task frontier for an actor, called by the actor when
  // saving a checkpoint.
  // The ActorFrontier response to a GetActorFrontierRequest. The raylet
  // returns the actor's per-handle task counts and execution dependencies,
  // which can later be used as the argument to SetActorFrontier
  // when resuming from the checkpoint.
  rpc GetActorFrontier(GetActorFrontierRequest) returns (GetActorFrontierReply);
  // A request to set the task frontier for an actor, called when resuming from
  // a checkpoint. The raylet will update the actor's per-handle task
  // counts and execution dependencies, discard any tasks that already executed
  // before the checkpoint, and make any tasks on the frontier runnable by
  // making their execution dependencies available.
  rpc SetActorFrontier(SetActorFrontierRequest) returns (SetActorFrontierReply);
  // Wait for objects to be ready either from local or remote Plasma stores.
  // The response message to WaitRequest; replies with the objects found and objects
  // remaining.
  rpc Wait(WaitRequest) returns (WaitReply);
  // Push an error to the relevant driver. This is sent from a worker to the
  // node manager.
  rpc PushError(PushErrorRequest) returns (PushErrorReply);
  // Push some profiling events to the GCS. When sending this message to the
  // node manager, the message itself is serialized as a ProfileTableData object.
  rpc PushProfileEvents(PushProfileEventsRequest) returns (PushProfileEventsReply);
  // Free the objects in objects store.
  rpc FreeObjectsInObjectStore(FreeObjectsInObjectStoreRequest) returns (FreeObjectsInObjectStoreReply);
  // Request raylet backend to prepare a checkpoint for an actor.
  // Reply of `PrepareActorCheckpointRequest`.
  rpc PrepareActorCheckpoint(PrepareActorCheckpointRequest) returns (PrepareActorCheckpointReply);
  // Notify raylet backend that an actor was resumed from a checkpoint.
  rpc NotifyActorResumedFromCheckpoint(NotifyActorResumedFromCheckpointRequest) returns (NotifyActorResumedFromCheckpointReply);
  // Set dynamic custom resource
  rpc SetResource(SetResourceRequest) returns (SetResourceReply);
}
