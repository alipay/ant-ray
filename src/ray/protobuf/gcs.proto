// Copyright 2017 The Ray Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";
option cc_enable_arenas = true;

package ray.rpc;

import "src/ray/protobuf/common.proto";

option java_package = "io.ray.runtime.generated";

// These indexes are mapped to table names in backend storage.
enum TablePrefix {
  TABLE_PREFIX_MIN = 0;
  UNUSED = 1;
  TASK = 2;
  RAYLET_TASK = 3;
  NODE = 4;
  OBJECT = 5;
  ACTOR = 6;
  FUNCTION = 7;
  TASK_RECONSTRUCTION = 8;
  RESOURCE_USAGE_BATCH = 9;
  JOB = 10;
  PROFILE = 11;
  TASK_LEASE = 12;
  KV = 13;
  NODE_RESOURCE = 14;
  DIRECT_ACTOR = 15;
  // WORKER is already used in WorkerType, so use WORKERS here.
  WORKERS = 16;
  RAYLET_WORKER = 17;
  NAMESPACE = 18;
  INIT_JOB_ENV = 19;
  INTERNAL_CONFIG = 20;
  PLACEMENT_GROUP_SCHEDULE = 21;
  PLACEMENT_GROUP = 22;
  JOB_STATE = 23;
  ACTOR_TASK_SPEC = 25;
  JOB_DATA = 26;
  FROZEN_NODES_DATA = 27;
  WORKER_RUNTIME_RESOURCE = 28;
}

// The channel that Add operations to the Table should be published on, if any.
enum TablePubsub {
  TABLE_PUBSUB_MIN = 0;
  NO_PUBLISH = 1;
  TASK_PUBSUB = 2;
  RAYLET_TASK_PUBSUB = 3;
  NODE_PUBSUB = 4;
  OBJECT_PUBSUB = 5;
  ACTOR_PUBSUB = 6;
  RESOURCE_USAGE_BATCH_PUBSUB = 7;
  TASK_LEASE_PUBSUB = 8;
  JOB_PUBSUB = 9;
  NODE_RESOURCE_PUBSUB = 10;
  DIRECT_ACTOR_PUBSUB = 11;
  WORKER_FAILURE_PUBSUB = 12;
  TABLE_PUBSUB_MAX = 13;
}

enum GcsChangeMode {
  APPEND_OR_ADD = 0;
  REMOVE = 1;
}

message GcsEntry {
  GcsChangeMode change_mode = 1;
  bytes id = 2;
  repeated bytes entries = 3;
}

message ObjectTableData {
  // The node manager ID that this object appeared on or was evicted by.
  bytes manager = 1;
}

message TaskReconstructionData {
  // The ID of task.
  bytes task_id = 1;
  // The number of times this task has been reconstructed so far.
  uint64 num_reconstructions = 2;
  // The node manager that is trying to reconstruct the task.
  bytes node_manager_id = 3;
}

message TaskTableData {
  Task task = 1;
}

message ActorTableData {
  // State of an actor.
  enum ActorState {
    // Actor info is registered in GCS. But its dependencies are not ready.
    DEPENDENCIES_UNREADY = 0;
    // Actor local dependencies are ready. This actor is being created.
    PENDING_CREATION = 1;
    // Actor is alive.
    ALIVE = 2;
    // Actor is dead, now being restarted.
    // After reconstruction finishes, the state will become alive again.
    RESTARTING = 3;
    // Actor is already dead and won't be restarted.
    DEAD = 4;
  }
  // The ID of the actor that was created.
  bytes actor_id = 1;
  // The ID of the caller of the actor creation task.
  bytes parent_id = 2;
  // The dummy object ID returned by the actor creation task. If the actor
  // dies, then this is the object that should be restarted for the actor
  // to be recreated.
  bytes actor_creation_dummy_object_id = 3;
  // The ID of the job that created the actor.
  bytes job_id = 4;
  // Current state of this actor.
  ActorState state = 6;
  // Max number of times this actor should be restarted,
  // a value of -1 indicates an infinite number of reconstruction attempts.
  int64 max_restarts = 7;
  // Number of restarts that has been tried on this actor.
  // This will be greater by 1 than what's published before in ALIVE.
  // ALIVE:0 RESTARTING:1 ALIVE:1 RESTARTING:2, etc
  uint64 num_restarts = 8;
  // The address of the the actor.
  Address address = 9;
  // The address of the the actor's owner (parent).
  Address owner_address = 10;
  // Whether the actor is persistent.
  bool is_detached = 11;
  // Name of the actor. Only populated if is_detached is true.
  string name = 12;
  // Last timestamp that the actor state was updated in millisecond.
  double timestamp = 13;
  // Language the job uses.
  Language language = 14;
  // Resource mapping ids acquired by the leased worker. This field is only set when this
  // actor already has a leased worker.
  repeated ResourceMapEntry resource_mapping = 15;
  // The process id of this actor.
  uint32 pid = 16;
  // The actor's namespace. Named `ray_namespace` to avoid confusions when invoked in c++.
  string ray_namespace = 19;
  // Runtime required to run this actor
  // It'll only be set if it's a detached actor and the original job has this field
  RuntimeEnv runtime_env = 20;
  // The unix ms timestamp the actor was started at.
  uint64 start_time = 21;
  // The unix ms timestamp the actor was ended at.
  uint64 end_time = 22;
  // The actor's class name. This is necessary because the task spec's lifetime
  // is shorter than the ActorTableData.
  string class_name = 23;
  // The actor's serialized runtime environment. This is necessary because the
  // task spec's lifetime is shorter than the ActorTableData.
  string serialized_runtime_env = 24;
  // Contains metadata about why the actor is dead.
  ActorDeathCause death_cause = 25;
  // === ANT-INTERNAL below ===
  // The function descriptor of the actor creation task.
  FunctionDescriptor function_descriptor = 30;
  // ID of the worker process, generated in gcs server.
  // It is use to both scheduling and failover.
  bytes worker_process_id = 31;
  // Field used for storing application-level extensions to the actor definition.
  // See ActorCreationTaskSpec.
  string extension_data = 32;
  // The max number of times tasks submitted on this actor should be retried
  // if the actor fails and is restarted.
  // If this number is 0 the tasks won't be resubmitted.
  // If this number is -1 the tasks will be resubmitted indefinitely.
  int64 max_task_retries = 33;
  map<string, double> required_resources = 34;
  map<string, string> extended_properties = 35;
  // === ANT-INTERNAL above ===
}

message GcsWorkerProcessRuntimeResourceTableData {
  bytes worker_process_id = 1;
  map<string, double> runtime_resources = 2;
}
message ErrorTableData {
  // The ID of the job that the error is for.
  bytes job_id = 1;
  // The type of the error.
  string type = 2;
  // The error message.
  string error_message = 3;
  // The IP address of the node manager.
  string node_manager_address = 4;
  // The timestamp of the error message.
  double timestamp = 5;
}

message PlacementGroupBundlesChangedNotification {
  // ID of the PlacementGroup.
  bytes placement_group_id = 1;
  // A list whose index is `bundle index` and value is a bool that represents the bundle
  // index is valid or not.
  repeated bool bundles = 2;
}

message ScheduleData {
  map<string, bytes> schedule_plan = 1;
}

message ProfileTableData {
  // Represents a profile event.
  message ProfileEvent {
    // The type of the event.
    string event_type = 1;
    // The start time of the event.
    double start_time = 2;
    // The end time of the event. If the event is a point event, then this
    // should be the same as the start time.
    double end_time = 3;
    // Additional data associated with the event. This data must be serialized
    // using JSON.
    string extra_data = 4;
  }

  // The type of the component that generated the event, e.g., worker or
  // object_manager, or node_manager.
  string component_type = 1;
  // An identifier for the component that generated the event.
  bytes component_id = 2;
  // An identifier for the node that generated the event.
  string node_ip_address = 3;
  // This is a batch of profiling events. We batch these together for
  // performance reasons because a single task may generate many events, and
  // we don't want each event to require a GCS command.
  repeated ProfileEvent profile_events = 4;
}

message StatsMetrics {
  message Tag {
    // Tag key.
    string key = 1;
    // Tag value.
    string value = 2;
  }
  message Metric {
    // Unique name for each metric.
    string metric_name = 1;
    double value = 2;
    // Record timestamp(UTC).
    uint64 timestamp = 3;
    // Metric tag map.
    repeated Tag tags = 4;
  }
  // Nodemanager ip address of reporter.
  string node_ip_address = 1;
  repeated Metric Metrics = 2;
}

message ResourceTableData {
  // The total capacity of this resource type.
  double resource_capacity = 1;
}

message AvailableResources {
  // Node id.
  bytes node_id = 1;
  // Resource capacity currently available on this node manager.
  map<string, double> resources_available = 2;
}

message BasicGcsNodeInfo {
  // State of a node.
  enum GcsNodeState {
    // Node is alive.
    ALIVE = 0;
    // Node is dead.
    DEAD = 1;
  }
  // The ID of node.
  bytes node_id = 1;
  // The IP address of the node manager.
  string node_manager_address = 2;
  // The port at which the node manager is listening for TCP
  // connections from other node managers.
  int32 node_manager_port = 5;
  // The port at which the object manager is listening for TCP
  // connections from other object managers.
  int32 object_manager_port = 6;

  // Current state of this node.
  GcsNodeState state = 7;

  // The name of this node. If this is not empty, it must be unique across the cluster.
  // If node_name is set, when GCS receives a Raylet registration, GCS will kill the old
  // node which has the same name.
  string node_name = 15;

  // The Hostname address of the node manager.
  string node_manager_hostname = 8;

  // Timestamp that the node is dead.
  int64 timestamp = 14;
}

message GcsNodeInfo {
  // The basic node info
  BasicGcsNodeInfo basic_gcs_node_info = 22;

  // The IPC socket name of raylet.
  string raylet_socket_name = 3;

  // The IPC socket name of the node's plasma store.
  string object_store_socket_name = 4;

  // The port at which the node will expose metrics to.
  int32 metrics_export_port = 9;

  // The pid of raylet.
  int32 pid = 12;

  // The brpc port of raylet.
  int32 brpc_port = 13;

  // The timestamp when the node is ALIVE.
  double start_time = 10;
  // The timestamp when the node is DEAD.
  double terminate_time = 11;

  // The resource group that the node belongs to.
  string shape_group = 16;
  // Name of pod that the node belongs to.
  string pod_name = 17;
  // The ID of the physical machine on which this node is deployed.
  string machine_id = 18;

  // The total resources of this node.
  map<string, double> resources_total = 21;
}

message HeartbeatTableData {
  // Node id.
  bytes node_id = 1;
}

// Data for a lease on task execution.
message TaskLeaseData {
  // The task ID.
  bytes task_id = 1;
  // Node manager ID.
  bytes node_manager_id = 2;
  // The time that the lease was last acquired at. NOTE(swang): This is the
  // system clock time according to the node that added the entry and is not
  // synchronized with other nodes.
  uint64 acquired_at = 3;
  // The period that the lease is active for.
  uint64 timeout = 4;
}

message JobConfig {
  enum ActorLifetime {
    NONE = 0;
    DETACHED = 1;
    NON_DETACHED = 2;
  }

  // Environment variables to be set on worker processes.
  map<string, string> worker_env = 1;
  // The number of java workers per worker process.
  uint32 num_java_workers_per_process = 2;
  // The jvm options for java workers of the job.
  repeated string jvm_options = 3;
  // A list of directories or files (jar files or dynamic libraries) that specify the
  // search path for user code. This will be used as `CLASSPATH` in Java, and `PYTHONPATH`
  // in Python. In C++, libraries under these paths will be loaded by 'dlopen'.
  repeated string code_search_path = 4;
  // Runtime environment to run the code
  RuntimeEnv runtime_env = 5;
  // The job's namespace. Named `ray_namespace` to avoid confusions when invoked in c++.
  string ray_namespace = 6;
  // Serialized JSON string of the parsed runtime environment dict for this job.
  string serialized_runtime_env = 7;
  // An opaque kv store for job related metadata.
  map<string, string> metadata = 8;
  // === ANT-INTERNAL below ===
  // The default memory of java worker process in units.
  uint64 java_worker_process_default_memory_units = 9;
  // The number of initial java worker processes of the job.
  // This is an experimental option. Use this at your own risks.
  // NOTE: This field is no longer used as the underlying scheduling logic does not depend
  // on this parameter any more. We continue to have this field to compatible some old
  // jobs. DO NOT DELETE.
  uint32 num_initial_java_worker_processes = 10;
  // The fraction of each java worker's heap size over its total memory.
  float java_heap_fraction = 11;
  // The total memory that the job can use.
  uint64 total_memory_units = 12;
  // The total gpus that the job can use.
  uint64 total_gpus = 13;
  // The total cpus that the job can use.
  uint64 total_cpus = 14;
  // The max of total memory that the job can use.
  uint64 max_total_memory_units = 15;
  // The max of total gpus that the job can use.
  uint64 max_total_gpus = 16;
  // The max of total cpus that the job can use.
  uint64 max_total_cpus = 17;
  // Whether to clean up actors, objects and tasks associated with this job during the
  // shutdown process of the driver.
  bool long_running = 18;
  // Whether to enable L1 fault tolerance.
  bool enable_l1_fault_tolerance = 19;
  // Level of logging for user's code.
  string logging_level = 20;
  // The maximum submitted task number before backpressure.
  bool actor_task_back_pressure_enabled = 21;
  int64 max_pending_calls = 22;
  ActorLifetime default_actor_lifetime = 23;
  // The number of global owners.
  uint32 global_owner_number = 24;

  // This is a workaround field that show the job state as failed
  // when GEAFLOW users invoke `KillCurrentJob()` API.
  bool mark_job_state_as_failed_when_killing = 30;
}

message JobTableData {
  enum JobState {
    INIT = 0;
    SUBMITTED = 1;
    RUNNING = 2;
    FINISHED = 3;
    FAILED = 4;
    CANCEL = 5;
  }
  enum DriverExitState {
    UNKNOWN = 0;
    OK = 1;
    ERROR = 2;
  }
  // The job ID.
  bytes job_id = 1;
  // Whether it's dead.
  bool is_dead = 2;
  // The UNIX timestamp corresponding to this event (job added or removed).
  double timestamp = 3;
  // IP address of the driver that started this job.
  string driver_ip_address = 4;
  // Process ID of the driver running this job.
  int64 driver_pid = 5;
  // The config of this job.
  JobConfig config = 6;
  // The timestamp the job was started at.
  uint64 start_time = 7;
  // The timestamp the job was ended at.
  uint64 end_time = 8;
  // Hostname of the node this job was started on.
  string driver_hostname = 9;
  // Raylet which the job's driver belongs to
  bytes raylet_id = 10;
  // Language the job uses
  Language language = 11;
  // Job state.
  JobState state = 12;
  // nodegroup id.
  string nodegroup_id = 13;
  // job payload.
  string job_payload = 14;
  // The reason for the job failure.
  string fail_error_message = 15;
  // The driver cmdline.
  string driver_cmdline = 16;
  // driver exit state.
  DriverExitState driver_exit_state = 18;
  // Whether the job is waiting for all actors to stop.
  // This field is valid only if L1 fault tolerance is enabled for the job.
  bool is_waiting_for_actors_to_stop = 19;
  // The job name.
  string job_name = 20;
  // Whether to allow pre-initialize the job runtime environment.
  bool pre_initialize_job_runtime_env_enabled = 21;
}

message NodeInfo {
  bytes node_id = 1;
  repeated JobInfo job_info_list = 2;
  map<string, double> total_resources = 3;
  map<string, double> available_resources = 4;
}

message JobInfo {
  bytes job_id = 1;
  repeated WorkerInfo worker_info_list = 2;
}

message WorkerInfo {
  bytes worker_process_id = 1;
  bool is_shared = 2;
  int32 slot_capacity = 3;
  map<string, double> required_resources = 4;
  map<string, double> acquired_resources = 5;
  map<string, double> runtime_resources = 6;
  Language language = 7;
  int32 pid = 8;
}

message ResourceInfo {
  int32 capacity = 1;
  int32 count = 2;
}

message WorkerTableData {
  // Is this worker alive.
  bool is_alive = 1;
  // Address of the worker that failed.
  Address worker_address = 2;
  // The UNIX timestamp at which this worker's state was updated.
  int64 timestamp = 3;
  // Whether it's an intentional disconnect, only applies then `is_alive` is false.
  WorkerExitType exit_type = 4;
  // Type of this worker.
  WorkerType worker_type = 5;
  // This is for AddWorker.
  map<string, bytes> worker_info = 6;
  // ID of the job that the worker belongs to.
  bytes job_id = 7;
  // ID of the worker process, generated in gcs server.
  bytes worker_process_id = 8;
  // The exception thrown in creation task. This field is set if this worker died because
  // of exception thrown in actor's creation task. Only applies when is_alive=false.
  RayException creation_task_exception = 18;
}

// Fields to publish when worker fails.
message WorkerDeltaData {
  bytes raylet_id = 1;
  bytes worker_id = 2;
}

message ResourceMap {
  map<string, ResourceTableData> items = 1;
}

message StoredConfig {
  string config = 1;
}

message ObjectLocationInfo {
  bytes object_id = 1;
  repeated ObjectTableData locations = 2;
  // For objects that have been spilled to external storage, the URL from which
  // they can be retrieved.
  string spilled_url = 3;
  // The node id that spills the object to the disk.
  // It will be Nil if it uses a distributed external storage.
  bytes spilled_node_id = 4;
  // The size of the object in bytes.
  uint64 size = 5;
}

// A notification message about one object's locations being changed.
message ObjectLocationChange {
  bool is_add = 1;
  // The node manager ID that this object appeared on or was evicted by.
  bytes node_id = 2;
  // The object has been spilled to this URL. This should be set xor the above
  // fields are set.
  string spilled_url = 3;
  // The node id that spills the object to the disk.
  // It will be Nil if it uses a distributed external storage.
  bytes spilled_node_id = 4;
  // The size of the object in bytes.
  uint64 size = 5;
}

// A notification message about one node's resources being changed.
message NodeResourceChange {
  // ID of the node whose resources have changed.
  bytes node_id = 1;
  // Labels of the updated resources and their latest capacities.
  map<string, double> updated_resources = 2;
  // Labels of the resources that were deleted.
  repeated string deleted_resources = 3;
}

message PubSubMessage {
  bytes id = 1;
  bytes data = 2;
}

message JobEnvInitNotification {
  JobTableData job_table_data = 1;
  bool start_driver = 2;
}

message NodeShape {
  string shape_group = 1;
  map<string, int32> resource_shape = 2;
}

message NodeSpec {
  // The resource shape of the node (`shape_gorup` is embedded in this filed).
  NodeShape node_shape = 1;
  // The name of pod that the node in.
  string pod_name = 2;
}

message NodegroupData {
  string nodegroup_id = 1;
  string nodegroup_name = 2;
  // If true (default), multiple jobs submitted to this nodegroup will share all the nodes
  // in this nodegroup. Otherwise, we will create a sub-nodegroup for each job upon
  // submission.
  bool enable_sub_nodegroup_isolation = 3;
  map<string, NodeSpec> host_to_node_spec = 5;
  map<string, string> schedule_options = 6;
  bool is_removed = 7;
  bool enable_revision = 8;
  uint64 revision = 9;
  string user_data = 10;
  uint64 nodegroup_updated_timestamp = 11;
  bool enable_job_quota = 12;
}

// === ANT-INTERNAL below
message ApiServerAddress {
  string ip = 1;
  int32 port = 2;
}
///////////////////////////////////////////////////////////////////////////////
/* Please do not modify/remove/change the following messages to maintain
backwards compatibility in autoscaler. This is necessary to make sure we can
run autoscaler with any version of ray. For example, the K8s operator runs
autoscaler in a separate pod, if the user upgrades the ray version on the head
pod autoscaler can crash (if the newer version of ray modified the messages
below). */

// Represents the demand for a particular resource shape.
message ResourceDemand {
  // The resource shape requested. This is a map from the resource string
  // (e.g., "CPU") to the amount requested.
  map<string, double> shape = 1;
  // The number of requests that are ready to run (i.e., dependencies have been
  // fulfilled), but that are waiting for resources.
  uint64 num_ready_requests_queued = 2;
  // The number of requests for which there is no node that is a superset of
  // the requested resource shape.
  uint64 num_infeasible_requests_queued = 3;
  // The number of requests of this shape still queued in CoreWorkers that this
  // raylet knows about.
  int64 backlog_size = 4;
}

// Represents the demand sorted by resource shape.
message ResourceLoad {
  // A list of all resource demands. The resource shape in each demand is
  // unique.
  repeated ResourceDemand resource_demands = 1;
}

message ResourcesData {
  // Node id.
  bytes node_id = 1;
  // Resource capacity currently available on this node manager.
  map<string, double> resources_available = 2;
  // Indicates whether available resources is changed. Only used when light
  // heartbeat enabled.
  bool resources_available_changed = 3;
  // Total resource capacity configured for this node manager.
  map<string, double> resources_total = 4;
  // Aggregate outstanding resource load on this node manager.
  map<string, double> resource_load = 5;
  // Indicates whether resource load is changed. Only used when
  // light heartbeat enabled.
  bool resource_load_changed = 6;
  // The resource load on this node, sorted by resource shape.
  ResourceLoad resource_load_by_shape = 7;
  // Whether this node manager is requesting global GC.
  bool should_global_gc = 8;
  // IP address of the node.
  string node_manager_address = 9;
  // === ANT-INTERNAL below ===
  // Normal task resources.
  map<string, double> resources_normal_task = 10;
  // Indicates whether resource normal task is changed. Only used when
  // light heartbeat enabled.
  bool resources_normal_task_changed = 11;
  // The timestamp that normal task resources are measured.
  int64 resources_normal_task_timestamp = 12;
}

message ResourceUsageBatchData {
  repeated ResourcesData batch = 1;
  // The total resource demand on all nodes included in the batch, sorted by
  // resource shape.
  ResourceLoad resource_load_by_shape = 2;
  // The pending list of placement groups.
  PlacementGroupLoad placement_group_load = 3;
}

message PlacementGroupLoad {
  // The list of pending placement group specifications.
  repeated PlacementGroupTableData placement_group_data = 1;
}

message PlacementGroupTableData {
  // State of a placement group.
  enum PlacementGroupState {
    // Placement Group is pending or scheduling
    PENDING = 0;
    // Placement Group is created.
    CREATED = 1;
    // Placement Group is already removed and won't be reschedule.
    REMOVED = 2;
    // Placement Group is rescheduling because the node it placed is dead.
    RESCHEDULING = 3;
    // Placement Group is updating because bundles are updated.
    // Note this state can only be transformed from the state of `CREATED` or `UPDATED`.
    UPDATING = 4;
  }

  // ID of the PlacementGroup.
  bytes placement_group_id = 1;
  // The name of the placement group.
  string name = 2;
  // The array of the bundle in Placement Group.
  repeated Bundle bundles = 3;
  // The schedule strategy of this Placement Group.
  PlacementStrategy strategy = 4;
  // Current state of this placement group.
  PlacementGroupState state = 5;
  // Fields to detect the owner of the placement group
  // for automatic lifecycle management.
  // The job id that created this placement group.
  bytes creator_job_id = 6;
  // The actor id that created this placement group.
  bytes creator_actor_id = 7;
  // Whether or not if the creator job is dead.
  bool creator_job_dead = 8;
  // Whether or not if the creator actor is dead.
  bool creator_actor_dead = 9;
  // Whether the placement group is persistent.
  bool is_detached = 10;
  // The pg's namespace. Named `ray_namespace` to avoid confusions when invoked in c++.
  string ray_namespace = 11;
}

message FrozenNodesNotification {
  repeated bytes frozen_node_set = 1;
}

message ActorMigrationNotification {
  repeated bytes actor_id_set = 1;
  bytes node_name = 3;
}

message ActorMigrationNotificationBatch {
  int64 migration_id = 1;
  repeated ActorMigrationNotification notification_list = 2;
}

message NodeResources {
  bytes node_id = 1;
  map<string, double> total_resources = 2;
  map<string, double> available_resources = 3;
}
///////////////////////////////////////////////////////////////////////////////
