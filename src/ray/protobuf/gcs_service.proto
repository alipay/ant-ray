// Copyright 2017 The Ray Authors.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//  http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";
option cc_enable_arenas = true;
package ray.rpc;

import "src/ray/protobuf/common.proto";
import "src/ray/protobuf/gcs.proto";

message SubmitJobRequest {
  // job id.
  bytes job_id = 1;
  // job name.
  string job_name = 2;
  // Language the job uses
  Language language = 3;
  // nodegroup id.
  string nodegroup_id = 4;
  // job payload.
  string job_payload = 5;
  // min resource requirements.
  map<string, double> min_resource_requirements = 6;
  // max resource requirements.
  map<string, double> max_resource_requirements = 7;
  // Number of nodes and their resource shapes required by this job.
  // if this field is set, the job must be submitted to a nodegroup that enables
  // sub-nodegroup isolation.
  repeated NodeShapeAndCount node_shape_and_count_list = 8;
  // Whether to allow pre-initialize the job runtime environment.
  bool pre_initialize_job_runtime_env_enabled = 9;
}

message SubmitJobReply {
  GcsStatus status = 1;
  bytes conflict_job_id = 2;
}

message DropJobRequest {
  // job id.
  bytes job_id = 1;
  // ANT-INTERNAL: Drop this job and mark this job as failed in GCS.
  bool mark_as_failed = 2;
}

message DropJobReply {
  GcsStatus status = 1;
}

message AddJobRequest {
  JobTableData data = 1;
}

message AddJobReply {
  GcsStatus status = 1;
}

message NotifyDriverExitRequest {
  bytes job_id = 1;
  bool exit_with_error = 2;
}

message NotifyDriverExitReply {
  GcsStatus status = 1;
}

message MarkJobFailedRequest {
  bytes job_id = 1;
  string error_message = 2;
  string driver_cmdline = 3;
}

message MarkJobFailedReply {
  GcsStatus status = 1;
}

message GetJobRequest {
  bytes job_id = 1;
}

message GetJobReply {
  GcsStatus status = 1;
  JobTableData data = 2;
}

message GetAllJobInfoRequest {
}

message GetAllJobInfoReply {
  GcsStatus status = 1;
  repeated JobTableData job_info_list = 2;
}

message GetJobErrorRequest {
  // job id.
  bytes job_id = 1;
}

message GetJobErrorReply {
  GcsStatus status = 1;
  repeated ErrorTableData errors = 2;
}

message UpdateJobResourceRequirementsRequest {
  // job id.
  bytes job_id = 1;
  map<string, double> min_resource_requirements = 2;
  map<string, double> max_resource_requirements = 3;
}

message UpdateJobResourceRequirementsReply {
  GcsStatus status = 1;
}

message ReportJobErrorRequest {
  ErrorTableData job_error = 1;
}

message ReportJobErrorReply {
  GcsStatus status = 1;
}

message GetNextJobIDRequest {
}

message GetNextJobIDReply {
  GcsStatus status = 1;
  int32 job_id = 2;
}

message PutJobDataRequest {
  // job id.
  bytes job_id = 1;
  bytes key = 2;
  bytes data = 3;
}

message PutJobDataReply {
  GcsStatus status = 1;
}

message GetJobDataRequest {
  // job id.
  bytes job_id = 1;
  bytes key = 2;
}

message GetJobDataReply {
  GcsStatus status = 1;
  bytes data = 2;
}

// Service for job info access.
service JobInfoGcsService {
  // Add job to GCS Service.
  rpc AddJob(AddJobRequest) returns (AddJobReply);
  // Get all job from GCS Service.
  rpc GetAllJobInfo(GetAllJobInfoRequest) returns (GetAllJobInfoReply);
  // Report job error.
  rpc ReportJobError(ReportJobErrorRequest) returns (ReportJobErrorReply);
  // === ANT-INTERNAL below ===
  // Submit job.
  rpc SubmitJob(SubmitJobRequest) returns (SubmitJobReply);
  // Drop job.
  rpc DropJob(DropJobRequest) returns (DropJobReply);
  // Notify GCS service that a driver has exited.
  rpc NotifyDriverExit(NotifyDriverExitRequest) returns (NotifyDriverExitReply);
  // Mark job as failed to GCS Service.
  rpc MarkJobFailed(MarkJobFailedRequest) returns (MarkJobFailedReply);
  // Get job from GCS Service.
  rpc GetJob(GetJobRequest) returns (GetJobReply);
  // Update job resources.
  rpc UpdateJobResourceRequirements(UpdateJobResourceRequirementsRequest)
      returns (UpdateJobResourceRequirementsReply);
  // TODO(po): We should delete the job data when the job is dropped.
  // TODO(po): Add DeleteJobData API.
  // Put job result to GCS Service.
  rpc PutJobData(PutJobDataRequest) returns (PutJobDataReply);
  // Get job result to GCS Service.
  rpc GetJobData(GetJobDataRequest) returns (GetJobDataReply);
  // Get next job id.
  rpc GetNextJobID(GetNextJobIDRequest) returns (GetNextJobIDReply);
  // Get available quota of all nodegroups.
  rpc GetAvailableQuotaOfAllNodegroups(GetAvailableQuotaOfAllNodegroupsRequest)
      returns (GetAvailableQuotaOfAllNodegroupsReply);
}

message GetActorInfoRequest {
  // ID of this actor. If actor_id is set, name will not be set.
  bytes actor_id = 1;
  // Name of the actor. This is only used for detached actors. If name is set,
  // actor_id will not be set.
  string name = 2;
}

message GetActorInfoReply {
  GcsStatus status = 1;
  // Data of actor.
  ActorTableData actor_table_data = 2;
}

message GetNamedActorInfoRequest {
  // Name of the actor.
  string name = 1;
  // Namespace of the actor.
  string ray_namespace = 2;
}

message GetNamedActorInfoReply {
  GcsStatus status = 1;
  // Data of actor.
  ActorTableData actor_table_data = 2;
}

message GetAllActorInfoRequest {
  // Whether or not to filter out actors which belong to dead jobs.
  bool show_dead_jobs = 1;
}

message GetAllActorInfoReply {
  GcsStatus status = 1;
  // Data of actor.
  repeated ActorTableData actor_table_data = 2;
}

// `KillActorViaGcsRequest` is sent to GCS Service to ask to kill an actor.
// `KillActorViaGcsRequest` is different from `KillActorRequest`.
// `KillActorRequest` is send to core worker to ask to kill an actor.
message KillActorViaGcsRequest {
  // ID of this actor.
  bytes actor_id = 1;
  // Whether to force kill the actor.
  bool force_kill = 2;
  // If set to true, the killed actor will not be restarted anymore.
  bool no_restart = 3;
}

message KillActorViaGcsReply {
  GcsStatus status = 1;
}

message GetJobDistributionRequest {
}

message GetJobDistributionReply {
  GcsStatus status = 1;
  repeated NodeInfo node_info_list = 2;
}

// Service for actor info access.
service ActorInfoGcsService {
  // Register actor to gcs service.
  rpc RegisterActor(RegisterActorRequest) returns (RegisterActorReply);
  // Create actor which local dependencies are resolved.
  rpc CreateActor(CreateActorRequest) returns (CreateActorReply);
  // Get actor data from GCS Service by actor id.
  rpc GetActorInfo(GetActorInfoRequest) returns (GetActorInfoReply);
  // Get actor data from GCS Service by name.
  rpc GetNamedActorInfo(GetNamedActorInfoRequest) returns (GetNamedActorInfoReply);
  // Get information of all actor from GCS Service.
  rpc GetAllActorInfo(GetAllActorInfoRequest) returns (GetAllActorInfoReply);
  rpc GetJobDistribution(GetJobDistributionRequest) returns (GetJobDistributionReply);
  // Kill actor via GCS Service.
  rpc KillActorViaGcs(KillActorViaGcsRequest) returns (KillActorViaGcsReply);
}

message RegisterNodeRequest {
  // Info of node.
  GcsNodeInfo node_info = 1;
}

message RegisterNodeReply {
  GcsStatus status = 1;
}

message UnregisterNodeRequest {
  // The ID of node.
  bytes node_id = 1;
}

message UnregisterNodeReply {
  GcsStatus status = 1;
}

message GetAllBasicNodeInfoRequest {
  string nodegroup_id = 1;
}

message GetAllBasicNodeInfoReply {
  GcsStatus status = 1;
  repeated BasicGcsNodeInfo node_info_list = 2;
}

message GetAllFullNodeInfoRequest {
  string nodegroup_id = 1;
}

message GetAllFullNodeInfoReply {
  GcsStatus status = 1;
  repeated GcsNodeInfo node_info_list = 2;
}

message GetInternalConfigRequest {
}

message GetInternalConfigReply {
  GcsStatus status = 1;
  string config = 2;
}

message UpdateInternalConfigRequest {
  // JSON formated string contains keys & values
  string config_json_str = 1;
}

message UpdateInternalConfigReply {
  GcsStatus status = 1;
}

message MarkFailureMachinesRequest {
  repeated string machine_list = 1;
}

message MarkFailureMachinesReply {
  GcsStatus status = 1;
}

message GetClusterResourcesRequest {
}

message GetClusterResourcesReply {
  GcsStatus status = 1;
  repeated NodeResources node_resources = 2;
}

message GetAllAvailableResourcesRequest {
}

message GetAllAvailableResourcesReply {
  GcsStatus status = 1;
  repeated AvailableResources resources_list = 2;
}

// Service for node info access.
service NodeInfoGcsService {
  // Register a node to GCS Service.
  rpc RegisterNode(RegisterNodeRequest) returns (RegisterNodeReply);
  // Unregister a node from GCS Service.
  rpc UnregisterNode(UnregisterNodeRequest) returns (UnregisterNodeReply);
  // Get basic information of all nodes from GCS Service.
  rpc GetAllBasicNodeInfo(GetAllBasicNodeInfoRequest) returns (GetAllBasicNodeInfoReply);
  // Get full information of all nodes from GCS Service.
  rpc GetAllFullNodeInfo(GetAllFullNodeInfoRequest) returns (GetAllFullNodeInfoReply);
  // Get cluster internal config.
  rpc GetInternalConfig(GetInternalConfigRequest) returns (GetInternalConfigReply);
  // Overwrite a config item in RayConfig
  rpc UpdateInternalConfig(UpdateInternalConfigRequest)
      returns (UpdateInternalConfigReply);
  // Mark physical machines with failures.
  rpc MarkFailureMachines(MarkFailureMachinesRequest) returns (MarkFailureMachinesReply);
}

message GetResourcesRequest {
  bytes node_id = 1;
}

message GetResourcesReply {
  GcsStatus status = 1;
  map<string, ResourceTableData> resources = 2;
}

message UpdateResourcesRequest {
  bytes node_id = 1;
  map<string, ResourceTableData> resources = 2;
}

message UpdateResourcesReply {
  GcsStatus status = 1;
}

message DeleteResourcesRequest {
  bytes node_id = 1;
  repeated string resource_name_list = 2;
}

message DeleteResourcesReply {
  GcsStatus status = 1;
}

message ReportResourceUsageRequest {
  ResourcesData resources = 1;
}

message ReportResourceUsageReply {
  GcsStatus status = 1;
}

message GetResourceUsageRequest {
  // The ID of node.
  bytes node_id = 1;
}

message GetResourceUsageReply {
  GcsStatus status = 1;
  ResourcesData resources = 2;
}

message ReportHeartbeatRequest {
  HeartbeatTableData heartbeat = 1;
}

message ReportHeartbeatReply {
  GcsStatus status = 1;
}

message CheckAliveRequest {
  int32 seq = 1;
}

message CheckAliveReply {
  GcsStatus status = 1;
  int32 seq = 2;
}

enum NodeRejectType {
  EXIT_AND_REPLACE_NODE = 0;
  EXIT_NODE = 1;
}

message RejectNodeRequest {
  bytes node_id = 1;
  NodeRejectType reject_type = 2;
}

message RejectNodeReply {
  GcsStatus status = 1;
}

// Service for heartbeat info access.
service HeartbeatInfoGcsService {
  // Report heartbeat of a node to GCS Service.
  rpc ReportHeartbeat(ReportHeartbeatRequest) returns (ReportHeartbeatReply);
  // Check alive. TODO(po): This should be removed after dashboard is able to find new
  // GCS.
  rpc CheckAlive(CheckAliveRequest) returns (CheckAliveReply);
  rpc RejectNode(RejectNodeRequest) returns (RejectNodeReply);
}

message GetObjectLocationsRequest {
  // The ID of object to lookup in GCS Service.
  bytes object_id = 1;
}

message GetObjectLocationsReply {
  GcsStatus status = 1;
  // Object location information.
  ObjectLocationInfo location_info = 2;
}

message GetAllObjectLocationsRequest {
}

message GetAllObjectLocationsReply {
  GcsStatus status = 1;
  // Data of object location info.
  repeated ObjectLocationInfo object_location_info_list = 2;
}

message AddObjectLocationRequest {
  // The ID of object which location will be added to GCS Service.
  bytes object_id = 1;
  // The location that will be added to GCS Service.
  bytes node_id = 2;
  // The spilled URL that will be added to GCS Service. Either this or the node
  // ID should be set.
  string spilled_url = 3;
  // The node id that spills the object to the disk.
  // It will be Nil if it uses a distributed external storage.
  bytes spilled_node_id = 4;
  // The size of the object in bytes.
  uint64 size = 5;
}

message AddObjectLocationReply {
  GcsStatus status = 1;
}

message AddObjectSpilledUrlReply {
  GcsStatus status = 1;
}

message RemoveObjectLocationRequest {
  // The ID of object which location will be removed from GCS Service.
  bytes object_id = 1;
  // The location that will be removed from GCS Service.
  bytes node_id = 2;
}

message RemoveObjectLocationReply {
  GcsStatus status = 1;
}

// Service for object info access.
service ObjectInfoGcsService {
  // Get object's locations from GCS Service.
  rpc GetObjectLocations(GetObjectLocationsRequest) returns (GetObjectLocationsReply);
  // Get all object's locations from GCS Service.
  rpc GetAllObjectLocations(GetAllObjectLocationsRequest)
      returns (GetAllObjectLocationsReply);
  // Add location of object to GCS Service.
  rpc AddObjectLocation(AddObjectLocationRequest) returns (AddObjectLocationReply);
  // Remove location of object from GCS Service.
  rpc RemoveObjectLocation(RemoveObjectLocationRequest)
      returns (RemoveObjectLocationReply);
}

message AddTaskRequest {
  TaskTableData task_data = 1;
}

message AddTaskReply {
  GcsStatus status = 1;
}

message GetTaskRequest {
  bytes task_id = 1;
}

message GetTaskReply {
  GcsStatus status = 1;
  TaskTableData task_data = 2;
}

message AddTaskLeaseRequest {
  TaskLeaseData task_lease_data = 1;
}

message AddTaskLeaseReply {
  GcsStatus status = 1;
}

message GetTaskLeaseRequest {
  bytes task_id = 1;
}

message GetTaskLeaseReply {
  GcsStatus status = 1;
  TaskLeaseData task_lease_data = 2;
}

message AttemptTaskReconstructionRequest {
  TaskReconstructionData task_reconstruction = 1;
}

message AttemptTaskReconstructionReply {
  GcsStatus status = 1;
}

// Service for task info access.
service TaskInfoGcsService {
  // Add a task to GCS Service.
  rpc AddTask(AddTaskRequest) returns (AddTaskReply);
  // Get task information from GCS Service.
  rpc GetTask(GetTaskRequest) returns (GetTaskReply);
  // Add a task lease to GCS Service.
  rpc AddTaskLease(AddTaskLeaseRequest) returns (AddTaskLeaseReply);
  // Get task lease information from GCS Service.
  rpc GetTaskLease(GetTaskLeaseRequest) returns (GetTaskLeaseReply);
  // Attempt task reconstruction to GCS Service.
  rpc AttemptTaskReconstruction(AttemptTaskReconstructionRequest)
      returns (AttemptTaskReconstructionReply);
}

message AddProfileDataRequest {
  ProfileTableData profile_data = 1;
}

message AddProfileDataReply {
  GcsStatus status = 1;
}

message GetAllProfileInfoRequest {
}

message GetAllProfileInfoReply {
  GcsStatus status = 1;
  repeated ProfileTableData profile_info_list = 2;
}

// Service for stats access.
service StatsGcsService {
  // Add profile data to GCS Service.
  rpc AddProfileData(AddProfileDataRequest) returns (AddProfileDataReply);
  // Get information of all profiles from GCS Service.
  rpc GetAllProfileInfo(GetAllProfileInfoRequest) returns (GetAllProfileInfoReply);
}

message ReportWorkerFailureRequest {
  WorkerTableData worker_failure = 1;
}

message ReportWorkerFailureReply {
  GcsStatus status = 1;
}

message GetWorkerInfoRequest {
  // ID of this worker.
  bytes worker_id = 1;
}

message GetWorkerInfoReply {
  GcsStatus status = 1;
  // Data of worker.
  WorkerTableData worker_table_data = 2;
}

message GetAllWorkerInfoRequest {
}

message GetAllWorkerInfoReply {
  GcsStatus status = 1;
  // Data of worker
  repeated WorkerTableData worker_table_data = 2;
}

message AddWorkerInfoRequest {
  WorkerTableData worker_data = 1;
}

message AddWorkerInfoReply {
  GcsStatus status = 1;
}

// Service for worker info access.
service WorkerInfoGcsService {
  // Report a worker failure to GCS Service.
  rpc ReportWorkerFailure(ReportWorkerFailureRequest) returns (ReportWorkerFailureReply);
  // Get worker information from GCS Service by worker id.
  rpc GetWorkerInfo(GetWorkerInfoRequest) returns (GetWorkerInfoReply);
  // Get information of all workers from GCS Service.
  rpc GetAllWorkerInfo(GetAllWorkerInfoRequest) returns (GetAllWorkerInfoReply);
  // Add worker information to GCS Service.
  rpc AddWorkerInfo(AddWorkerInfoRequest) returns (AddWorkerInfoReply);
}

message CreateActorRequest {
  TaskSpec task_spec = 1;
}

message CreateActorReply {
  GcsStatus status = 1;
  // The cause of this actor's death if creation was cancelled.
  ActorDeathCause death_cause = 2;
}

message RegisterActorRequest {
  TaskSpec task_spec = 1;
}

message RegisterActorReply {
  GcsStatus status = 1;
}

message CreatePlacementGroupRequest {
  PlacementGroupSpec placement_group_spec = 1;
}

message AddPlacementGroupBundlesRequest {
  bytes placement_group_id = 1;
  repeated Bundle bundles = 2;
}

message AddPlacementGroupBundlesReply {
  GcsStatus status = 1;
}

message RemovePlacementGroupBundlesRequest {
  bytes placement_group_id = 1;
  repeated int32 bundle_indexes = 2;
}

message RemovePlacementGroupBundlesReply {
  GcsStatus status = 1;
}

message CreatePlacementGroupReply {
  GcsStatus status = 1;
}

message RemovePlacementGroupRequest {
  bytes placement_group_id = 1;
}

message RemovePlacementGroupReply {
  GcsStatus status = 1;
}

message GetPlacementGroupRequest {
  bytes placement_group_id = 1;
}

message GetPlacementGroupReply {
  GcsStatus status = 1;
  PlacementGroupTableData placement_group_table_data = 2;
}

enum GcsServiceFailureType {
  RPC_DISCONNECT = 0;
  GCS_SERVER_RESTART = 1;
}

message ScheduleOptions {
  float pack_step = 1;
  float rare_resources_schedule_pack_step = 2;
  int32 num_candidate_nodes_for_scheduling = 3;
  map<string, int32> resource_weights = 4;
  map<string, int32> scorer_weights = 5;
  bool runtime_resource_scheduling_enabled = 6;
  uint32 runtime_resources_calculation_interval_s = 7;
  float runtime_memory_tail_percentile = 8;
  float runtime_cpu_tail_percentile = 9;
  uint32 runtime_resources_history_window_len_s = 10;
  float runtime_memory_history_window_tail = 11;
  float runtime_cpu_history_window_tail = 12;
  float overcommit_ratio = 13;
  float node_overcommit_ratio = 14;
  float job_resource_requirements_max_min_ratio_limit = 15;
}

message NodeShapeAndCount {
  int32 node_count = 1;
  NodeShape node_shape = 2;
}

message CreateOrUpdateNodegroupRequest {
  string nodegroup_id = 1;
  string nodegroup_name = 2;
  // If false (default), multiple jobs submitted to this nodegroup will share all the
  // nodes in this nodegroup. Otherwise, we will create a sub-nodegroup for each job
  // upon submission.
  bool enable_sub_nodegroup_isolation = 3;
  // categorized node set list.
  repeated NodeShapeAndCount node_shape_and_count_list = 4;
  ScheduleOptions schedule_options = 5;
  bool enable_revision = 6;
  // The latest revision of the current nodegroup at requester side.
  uint64 revision = 7;
  // The user data that could reply when get the namespace info.
  string user_data = 8;
  // Whether limiting jobs' quota.
  bool enable_job_quota = 9;
}

message CreateOrUpdateNodegroupReply {
  GcsStatus status = 1;
  uint64 revision = 2;
  map<string, NodeSpec> host_to_node_spec = 3;
}

message RemoveNodesFromNodegroupRequest {
  enum Mode {
    SOFT = 0;
    HARD = 1;
  }

  string nodegroup_id = 1;
  Mode mode = 2;
  repeated string host_name_list = 3;
}

message RemoveNodesFromNodegroupReply {
  GcsStatus status = 1;
  repeated bytes node_id_list = 2;
}

message RemoveNodegroupRequest {
  string nodegroup_id = 1;
}

message RemoveNodegroupReply {
  GcsStatus status = 1;
}

message GetAllNodegroupsRequest {
  bool include_sub_nodegroups = 1;
}

message GetAllNodegroupsReply {
  GcsStatus status = 1;
  repeated NodegroupData nodegroup_data_list = 2;
}

message GetResourcesOfAllNodegroupsRequest {
}

message GetLayeredResourcesOfAllNodegroupsRequest {
}

message ResourceList {
  double total = 1;
  double available = 2;
}

// Info of a host.
message LabelResourceMap {
  string shape_group = 1;
  bool has_driver = 2;
  map<string, ResourceList> resource_map = 3;
}

// Info of a (sub-)nodegroup.
message HostResourceMap {
  // Map contains this (sub-)nodegroup's hosts.
  map<string, LabelResourceMap> host_resource_map = 1;
}

message GetResourcesOfAllNodegroupsReply {
  GcsStatus status = 1;
  map<string, HostResourceMap> nodegroup_host_resource_map = 2;
}

// Info of a nodegroup.
message NodegroupLayer {
  HostResourceMap unassigned_hosts = 1;
  bool enable_sub_nodegroup_isolation = 2;
  uint64 revision = 3;
  // Map contains this nodegroup's sub-nodegroups.
  map<string, HostResourceMap> nodegroup_host_resource_map = 4;
}

message GetLayeredResourcesOfAllNodegroupsReply {
  GcsStatus status = 1;
  HostResourceMap total_unassigned_hosts = 2;
  map<string, NodegroupLayer> nodegroup_layer_map = 3;
}

message GetPendingResourcesOfAllNodegroupsRequest {
}

message PendingResourceDemands {
  ResourceLoad resource_load_by_shape = 1;
  PlacementGroupLoad placement_group_load = 2;
}

message GetPendingResourcesOfAllNodegroupsReply {
  GcsStatus status = 1;
  map<string, PendingResourceDemands> pending_resources = 2;
}

message GetAvailableQuotaOfAllNodegroupsRequest {
}

message NodegroupQuota {
  map<string, double> quota = 1;
}

message GetAvailableQuotaOfAllNodegroupsReply {
  GcsStatus status = 1;
  map<string, NodegroupQuota> nodegroup_to_quota_map = 2;
}

message ReleaseIdleNodesRequest {
  string nodegroup_id = 1;
}

message ReleaseIdleNodesReply {
  GcsStatus status = 1;
  repeated NodeShapeAndCount released_node_shape_and_count_list = 2;
  repeated NodeShapeAndCount remaining_node_shape_and_count_list = 3;
}

message AlternateNode {
  string alternate_host_name = 1;
  string to_be_migrated_host_name = 2;
}

message AddAlternateNodesForMigrationRequest {
  repeated AlternateNode alternate_node_list = 1;
}

message AddAlternateNodesForMigrationReply {
  GcsStatus status = 1;
}

service NodegroupInfoGcsService {
  // Add a number of node to the specified nodegroup by node shape.
  rpc CreateOrUpdateNodegroup(CreateOrUpdateNodegroupRequest)
      returns (CreateOrUpdateNodegroupReply);
  // Remove nodes from nodegroup.
  rpc RemoveNodesFromNodegroup(RemoveNodesFromNodegroupRequest)
      returns (RemoveNodesFromNodegroupReply);
  // Remove a nodegroup.
  rpc RemoveNodegroup(RemoveNodegroupRequest) returns (RemoveNodegroupReply);
  // Get all the nodegroup node list.
  rpc GetAllNodegroups(GetAllNodegroupsRequest) returns (GetAllNodegroupsReply);
  // Release idle nodes.
  rpc ReleaseIdleNodes(ReleaseIdleNodesRequest) returns (ReleaseIdleNodesReply);
  // Pin nodes for cluster scaling down.
  rpc PinNodesForClusterScalingDown(PinNodesForClusterScalingDownRequest)
      returns (PinNodesForClusterScalingDownReply);
  // Add alternate nodes for migration.
  rpc AddAlternateNodesForMigration(AddAlternateNodesForMigrationRequest)
      returns (AddAlternateNodesForMigrationReply);
}

message GetAllPlacementGroupRequest {
}

message GetAllPlacementGroupReply {
  GcsStatus status = 1;
  // Data of placement group
  repeated PlacementGroupTableData placement_group_table_data = 2;
}

message WaitPlacementGroupUntilReadyRequest {
  bytes placement_group_id = 1;
}

message WaitPlacementGroupUntilReadyReply {
  GcsStatus status = 1;
}

message GetNamedPlacementGroupRequest {
  // Name of the placement group.
  string name = 1;
  // Namespace to search.
  string ray_namespace = 2;
}

message GetNamedPlacementGroupReply {
  GcsStatus status = 1;
  // Data of placement group.
  PlacementGroupTableData placement_group_table_data = 2;
}

// Service for placement group info access.
service PlacementGroupInfoGcsService {
  // Create placement group via gcs service.
  rpc CreatePlacementGroup(CreatePlacementGroupRequest)
      returns (CreatePlacementGroupReply);
  // Add new bundles for the placement group via gcs service.
  rpc AddPlacementGroupBundles(AddPlacementGroupBundlesRequest)
      returns (AddPlacementGroupBundlesReply);
  // Remove bundles from the placement group via gcs service.
  rpc RemovePlacementGroupBundles(RemovePlacementGroupBundlesRequest)
      returns (RemovePlacementGroupBundlesReply);
  // Remove placement group via gcs service.
  rpc RemovePlacementGroup(RemovePlacementGroupRequest)
      returns (RemovePlacementGroupReply);
  // Get placement group information via gcs service.
  rpc GetPlacementGroup(GetPlacementGroupRequest) returns (GetPlacementGroupReply);
  // Get named placement group information via gcs service.
  rpc GetNamedPlacementGroup(GetNamedPlacementGroupRequest)
      returns (GetNamedPlacementGroupReply);
  // Get information of all placement group from GCS Service.
  rpc GetAllPlacementGroup(GetAllPlacementGroupRequest)
      returns (GetAllPlacementGroupReply);
  // Wait for placement group until ready.
  rpc WaitPlacementGroupUntilReady(WaitPlacementGroupUntilReadyRequest)
      returns (WaitPlacementGroupUntilReadyReply);
}

message FreezeNodesRequest {
  repeated string node_name_set = 1;
}

message FreezeNodesReply {
  GcsStatus status = 1;
}

message UnfreezeNodesRequest {
  repeated string node_name_set = 1;
}

message UnfreezeNodesReply {
  GcsStatus status = 1;
}

message GetAllFrozenNodesRequest {
}

message GetAllFrozenNodesReply {
  GcsStatus status = 1;
  repeated string frozen_node_set = 2;
}

message ReportFreezeDoneRequest {
  string node_name = 1;
  bytes node_id = 2;
}

message ReportFreezeDoneReply {
  GcsStatus status = 1;
}

service FrozenNodeGcsService {
  // Freeze nodes by node name
  rpc FreezeNodes(FreezeNodesRequest) returns (FreezeNodesReply);
  // Unfreeze nodes by node name
  rpc UnfreezeNodes(UnfreezeNodesRequest) returns (UnfreezeNodesReply);
  // Get all frozen nodes from GCS
  rpc GetAllFrozenNodes(GetAllFrozenNodesRequest) returns (GetAllFrozenNodesReply);

  rpc ReportFreezeDone(ReportFreezeDoneRequest) returns (ReportFreezeDoneReply);
}

message MigrateActorsInNodeRequest {
  repeated string node_name_list = 1;
}

message MigrateActorsInNodeReply {
  message ResultTuple {
    bool success = 1;
    string message = 2;
  }

  GcsStatus status = 1;
  map<string, ResultTuple> results = 2;
}

message CheckIfMigrationIsCompleteRequest {
  repeated string node_name_list = 1;
}

message CheckIfMigrationIsCompleteReply {
  GcsStatus status = 1;
  repeated string completed_node_name_list = 2;
  repeated string uncompleted_node_name_list = 3;
}

service ActorMigrationGcsService {
  rpc MigrateActorsInNode(MigrateActorsInNodeRequest) returns (MigrateActorsInNodeReply);
  rpc CheckIfMigrationIsComplete(CheckIfMigrationIsCompleteRequest)
      returns (CheckIfMigrationIsCompleteReply);
}

///////////////////////////////////////////////////////////////////////////////
/* Please do not modify/remove/change the following messages to maintain
backwards compatibility in autoscaler. This is necessary to make sure we can
run autoscaler with any version of ray. For example, the K8s operator runs
autoscaler in a separate pod, if the user upgrades the ray version on the head
pod autoscaler can crash (if the newer version of ray modified the messages
below). */

message InternalKVGetRequest {
  bytes key = 1;
}

message InternalKVGetReply {
  GcsStatus status = 1;
  bytes value = 2;
}

message InternalKVPutRequest {
  bytes key = 1;
  bytes value = 2;
  bool overwrite = 3;
}

message InternalKVPutReply {
  GcsStatus status = 1;
  int32 added_num = 2;
}

message InternalKVDelRequest {
  bytes key = 1;
}

message InternalKVDelReply {
  GcsStatus status = 1;
  int32 deleted_num = 2;
}

message InternalKVExistsRequest {
  bytes key = 1;
}

message InternalKVExistsReply {
  GcsStatus status = 1;
  bool exists = 2;
}

message InternalKVKeysRequest {
  bytes prefix = 1;
}

message InternalKVKeysReply {
  GcsStatus status = 1;
  repeated bytes results = 2;
}

// Service for KV storage
service InternalKVGcsService {
  rpc InternalKVGet(InternalKVGetRequest) returns (InternalKVGetReply);
  rpc InternalKVPut(InternalKVPutRequest) returns (InternalKVPutReply);
  rpc InternalKVDel(InternalKVDelRequest) returns (InternalKVDelReply);
  rpc InternalKVExists(InternalKVExistsRequest) returns (InternalKVExistsReply);
  rpc InternalKVKeys(InternalKVKeysRequest) returns (InternalKVKeysReply);
}

message GetAllResourceUsageRequest {
}

message GetAllResourceUsageReply {
  GcsStatus status = 1;
  ResourceUsageBatchData resource_usage_data = 2;
}

// Service for node resource info access.
service NodeResourceInfoGcsService {
  // Get node's resources from GCS Service.
  rpc GetResources(GetResourcesRequest) returns (GetResourcesReply);
  // Update resources of a node in GCS Service.
  rpc UpdateResources(UpdateResourcesRequest) returns (UpdateResourcesReply);
  // Delete resources of a node in GCS Service.
  rpc DeleteResources(DeleteResourcesRequest) returns (DeleteResourcesReply);
  // Get available resources of all nodes.
  rpc GetAllAvailableResources(GetAllAvailableResourcesRequest)
      returns (GetAllAvailableResourcesReply);
  // Report resource usage of a node to GCS Service.
  rpc ReportResourceUsage(ReportResourceUsageRequest) returns (ReportResourceUsageReply);
  // Get resource usage of all nodes from GCS Service.
  rpc GetAllResourceUsage(GetAllResourceUsageRequest) returns (GetAllResourceUsageReply);
  rpc GetResourceUsage(GetResourceUsageRequest) returns (GetResourceUsageReply);
  // Get resources of all nodegroups
  rpc GetResourcesOfAllNodegroups(GetResourcesOfAllNodegroupsRequest)
      returns (GetResourcesOfAllNodegroupsReply);
  // Get layered resources of all nodegroups
  rpc GetLayeredResourcesOfAllNodegroups(GetLayeredResourcesOfAllNodegroupsRequest)
      returns (GetLayeredResourcesOfAllNodegroupsReply);
  // Get pending resource demands of all nodegroups
  rpc GetPendingResourcesOfAllNodegroups(GetPendingResourcesOfAllNodegroupsRequest)
      returns (GetPendingResourcesOfAllNodegroupsReply);
  // Get cluster resources from GCS Service.
  rpc GetClusterResources(GetClusterResourcesRequest) returns (GetClusterResourcesReply);
}

message NodeRuntimeResources {
  // The ID of node.
  bytes node_id = 1;
  repeated WorkerRuntimeStat worker_stat_list = 2;
};

message ReportClusterRuntimeResourcesRequest {
  repeated NodeRuntimeResources node_runtime_resources_list = 1;
}

message ReportClusterRuntimeResourcesReply {
  GcsStatus status = 1;
}

service RuntimeResourceInfoGcsService {
  // Report cluster runtime resources.
  rpc ReportClusterRuntimeResources(ReportClusterRuntimeResourcesRequest)
      returns (ReportClusterRuntimeResourcesReply);
}

message PinNodesForClusterScalingDownRequest {
  repeated NodeShapeAndCount final_node_shape_and_count_list = 1;
  repeated string alive_node_list = 2;
}

message PinNodesForClusterScalingDownReply {
  GcsStatus status = 1;
  repeated string pinned_node_list = 2;
}

message GcsStatus {
  int32 code = 1;
  string message = 2;
}
///////////////////////////////////////////////////////////////////////////////
