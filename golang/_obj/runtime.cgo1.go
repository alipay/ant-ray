// Code generated by cmd/cgo; DO NOT EDIT.

//line pkg/ray/runtime.go:1:1
package ray; import _cgo_unsafe "unsafe"

/*
   #cgo CFLAGS: -I/root/ray/src/ray/core_worker/lib/golang
   #cgo LDFLAGS: -shared  -L/root/ray/bazel-bin/ -lcore_worker_library_go -lstdc++
   #include <stdlib.h>
   #include "go_worker.h"
*/
import _ "unsafe"
import (
    "errors"
    "fmt"
    "reflect"
    "strconv"
    "strings"
    "unsafe"

    "github.com/golang/protobuf/proto"
    ray_rpc "github.com/ray-project/ray-go-worker/pkg/ray/generated"
    "github.com/ray-project/ray-go-worker/pkg/util"
)

const sessionDir = "session_dir"

var typesMap = make(map[string]reflect.Type)

func Init(address, _redis_password string) {
    innerInit(address, _redis_password, ray_rpc.WorkerType_DRIVER)
}

func innerInit(address, _redis_password string, workerType ray_rpc.WorkerType) {
    util.Logger.Debug("Initializing runtime with config")
    gsa, err := NewGlobalStateAccessor(address, _redis_password)
    if err != nil {
        panic(err)
    }
    // for driver
    if workerType == ray_rpc.WorkerType_DRIVER {
        SetJobId(gsa.GetNextJobID())
        raySessionDir := gsa.GetInternalKV(sessionDir)
        if raySessionDir == "" {
            panic(fmt.Errorf("failed to get session dir"))
        }
        SetSessionDir(raySessionDir)
        gcsNodeInfo := &ray_rpc.GcsNodeInfo{}
        localIp, err := util.GetLocalIp()
        if err != nil {
            panic(err)
        }
        util.Logger.Debugf("Using local ip: %s", localIp)
        nodeInfoData := gsa.GetNodeToConnectForDriver(localIp)
        err = proto.Unmarshal(nodeInfoData, gcsNodeInfo)
        if err != nil {
            panic(err)
        }
        SetNodeManagerPort(gcsNodeInfo.GetNodeManagerPort())
        SetNodeManagerAddress(gcsNodeInfo.GetNodeManagerAddress())
        SetObjectStoreSocket(gcsNodeInfo.GetObjectStoreSocketName())
        SetRayletSocket(gcsNodeInfo.GetRayletSocketName())
        //todo add job config
    } else {
        // check session dir is not empty
        if GetSessionDir() == "" {
            panic(errors.New("session dir is empty"))
        }
    }

    util.Logger.Debugf("Session dir: %s", GetSessionDir())
    logDir := fmt.Sprintf("%s/logs", GetSessionDir())

    addressInfo := strings.Split(address, ":")
    addressPort, err := strconv.Atoi(addressInfo[1])
    if err != nil {
        panic(err)
    }
    serializedJobConfig := "{}"
    ( /*line :77:5*/_Cfunc_go_worker_Initialize /*line :77:26*/)( /*line :77:28*/_Ctype_int /*line :77:33*/(workerType), ( /*line :77:47*/_Cfunc_CString /*line :77:55*/)(GetObjectStoreSocket()),
        ( /*line :78:9*/_Cfunc_CString /*line :78:17*/)(GetRayletSocket()), ( /*line :78:39*/_Cfunc_CString /*line :78:47*/)(logDir),
        ( /*line :79:9*/_Cfunc_CString /*line :79:17*/)(GetNodeManagerAddress()),  /*line :79:45*/_Ctype_int /*line :79:50*/(GetNodeManagerPort()),
        ( /*line :80:9*/_Cfunc_CString /*line :80:17*/)(GetNodeManagerAddress()),
        ( /*line :81:9*/_Cfunc_CString /*line :81:17*/)("GOLANG"),  /*line :81:30*/_Ctype_int /*line :81:35*/(GetJobId()), ( /*line :81:49*/_Cfunc_CString /*line :81:57*/)(addressInfo[0]),  /*line :81:76*/_Ctype_int /*line :81:81*/(addressPort),
        ( /*line :82:9*/_Cfunc_CString /*line :82:17*/)(_redis_password), ( /*line :82:37*/_Cfunc_CString /*line :82:45*/)(serializedJobConfig))
}

func innerRun() {
    util.Logger.Infof("ray worker running...")
    ( /*line :87:5*/_Cfunc_go_worker_Run /*line :87:19*/)()
    util.Logger.Infof("ray worker exiting...")
}

func RegisterType(t reflect.Type) error {
    typeName := getRegisterTypeKey(t.Elem())
    typesMap[typeName] = t.Elem()
    util.Logger.Debugf("register type: %s", typeName)
    // todo check conflict
    return nil
}

func getRegisterTypeKey(t reflect.Type) string {
    return t.PkgPath() + "." + t.Name()
}

func Actor(p interface{}) *ActorCreator {
    //todo check contains
    return &ActorCreator{
        registerTypeName: getRegisterTypeKey(reflect.TypeOf(p).Elem()),
    }
}

type ActorCreator struct {
    registerTypeName string
}

// 创建actor
func (ac *ActorCreator) Remote() *ActorHandle {
    var res * /*line :116:14*/_Ctype_char /*line :116:20*/
    dataLen := func() _Ctype_int{ var _cgo0 *_Ctype_char = _Cfunc_CString(ac.registerTypeName); _cgoBase1 := /*line :117:72*/&res; _cgo1 := _cgoBase1; _cgoCheckPointer(_cgoBase1, 0 == 0); return _Cfunc_go_worker_CreateActor(_cgo0, _cgo1); }()
    if dataLen > 0 {
        defer func() func() { _cgo0 := /*line :119:22*/unsafe.Pointer(res); return func() { _cgoCheckPointer(_cgo0, nil); _Cfunc_free(_cgo0); }}()()
        return &ActorHandle{
            actorId:   func() []byte{ _cgo0 := /*line :121:34*/unsafe.Pointer(res); var _cgo1 _Ctype_int = /*line :121:55*/dataLen; _cgoCheckPointer(_cgo0, nil); return _Cfunc_GoBytes(_cgo0, _cgo1); }(),
            language:  ray_rpc.Language_GOLANG,
            actorType: typesMap[ac.registerTypeName],
        }
    }
    return nil
}

type ActorHandle struct {
    actorId   []byte
    language  ray_rpc.Language
    actorType reflect.Type
}

type Param interface {
}

type Convert func(a, i Param)

// 缺少泛型的支持，所以只能传入参数名
// 参数填这里
func (ah *ActorHandle) Task(f interface{}) *ActorTaskCaller {
    methodType := reflect.TypeOf(f)
    return &ActorTaskCaller{
        actorHandle:  ah,
        invokeMethod: methodType,
        params:       []reflect.Value{},
    }
}

type ActorTaskCaller struct {
    actorHandle  *ActorHandle
    invokeMethod reflect.Type
    params       []reflect.Value
}

// 发出调用
func (or *ActorTaskCaller) Remote() *ObjectRef {
    returnNum := or.invokeMethod.NumOut()
    objectIds := func() _Ctype_struct___0{ _cgo0 := func() _cgo_unsafe.Pointer{ _cgo0 := /*line :160:55*/or.actorHandle.actorId; _cgoCheckPointer(_cgo0, nil); return _Cfunc_CBytes(_cgo0); }(); var _cgo1 *_Ctype_char = _Cfunc_CString(or.invokeMethod.Name()); var _cgo2 _Ctype_int = _Ctype_int(returnNum); _cgoCheckPointer(_cgo0, nil); return _Cfunc_go_worker_SubmitActorTask(_cgo0, _cgo1, _cgo2); }()
    resultIds := make([]ObjectId, 0, len(objectIds))
    for _, objectId := range objectIds {
        resultIds = append(resultIds, ObjectId{
            id: func() []byte{ _cgo0 := /*line :164:27*/objectId.p; var _cgo1 _Ctype_int = /*line :164:39*/objectId.size; _cgoCheckPointer(_cgo0, nil); return _Cfunc_GoBytes(_cgo0, _cgo1); }(),
        })
    }
    return &ObjectRef{
        ids: resultIds,
    }
}

type ObjectRef struct {
    ids   []ObjectId
    types []reflect.Type
}

type ObjectId struct {
    id []byte
}

func (or *ObjectRef) Get() {

}

//export SayHello
func SayHello(str * /*line :186:20*/_Ctype_char /*line :186:26*/) {
    fmt.Println(( /*line :187:17*/_Cfunc_GoString /*line :187:26*/)(str) + " in go")
}
