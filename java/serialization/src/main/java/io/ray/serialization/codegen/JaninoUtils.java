package io.ray.serialization.codegen;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.Map;
import org.codehaus.janino.ByteArrayClassLoader;
import org.codehaus.janino.ClassLoaderIClassLoader;
import org.codehaus.janino.Compiler;
import org.codehaus.janino.util.resource.MapResourceCreator;
import org.codehaus.janino.util.resource.MapResourceFinder;
import org.codehaus.janino.util.resource.Resource;

/**
 * A util to compile code to bytecode and create classloader to load generated class. Based on
 * org.codehaus.janino.tests.CompilerTest#testInMemoryCompilation, see
 * (https://github.com/janino-compiler/janino/issues/52)
 */
public class JaninoUtils {

  public static ByteArrayClassLoader compile(
      ClassLoader parentClassLoader, CompileUnit... compileUnits) {
    final Map<String, byte[]> classes = toBytecode(parentClassLoader, compileUnits);
    // Set up a class loader that finds and defined the generated classes.
    return new ByteArrayClassLoader(classes, parentClassLoader);
  }

  public static Map<String, byte[]> toBytecode(
      ClassLoader parentClassLoader, CompileUnit... compileUnits) {
    MapResourceFinder sourceFinder = new MapResourceFinder();
    for (CompileUnit unit : compileUnits) {
      String stubFileName = unit.pkg.replace(".", "/") + "/" + unit.mainClassName + ".java";
      sourceFinder.addResource(stubFileName, unit.getCode());

      Path path = Paths.get(CodeGenerator.getCodeDir(), stubFileName).toAbsolutePath();
      try {
        path.getParent().toFile().mkdirs();
        if (CodeGenerator.deleteCodeOnExit()) {
          path.toFile().deleteOnExit();
        }
        Files.write(path, unit.getCode().getBytes());
      } catch (IOException e) {
        throw new RuntimeException(String.format("Write code file %s failed", path), e);
      }
    }

    // Storage for generated bytecode
    final Map<String, byte[]> classes = new HashMap<>();
    // Set up the compiler.
    ClassLoaderIClassLoader iClassLoader = new ClassLoaderIClassLoader(parentClassLoader);
    Compiler compiler = new Compiler(sourceFinder, iClassLoader);
    compiler.setClassFileCreator(new MapResourceCreator(classes));
    compiler.setClassFileFinder(new MapResourceFinder(classes));

    // set debug flag to get source file names and line numbers for debug and stacktrace.
    // this is also the default behaviour for javac.
    compiler.setDebugSource(true);
    compiler.setDebugLines(true);

    // Compile all sources
    try {
      compiler.compile(sourceFinder.resources().toArray(new Resource[0]));
    } catch (Exception e) {
      StringBuilder msgBuilder = new StringBuilder("Compile error: \n");
      for (int i = 0; i < compileUnits.length; i++) {
        CompileUnit unit = compileUnits[i];
        if (i != 0) {
          msgBuilder.append('\n');
        }
        String qualifiedName = unit.pkg + "." + unit.mainClassName;
        msgBuilder.append(qualifiedName).append(":\n");
        msgBuilder.append(CodeFormatter.format(unit.getCode()));
      }
      throw new CodegenException(msgBuilder.toString(), e);
    }

    return classes;
  }
}
