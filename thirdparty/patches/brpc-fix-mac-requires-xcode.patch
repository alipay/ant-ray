diff --git BUILD.bazel BUILD.bazel
index 58e8863..1ae29c5 100644
--- BUILD.bazel
+++ BUILD.bazel
@@ -217,6 +217,7 @@ BUTIL_SRCS = [
     "@bazel_tools//tools/osx:darwin": [
         "src/butil/time/time_mac.cc",
         "src/butil/mac/scoped_mach_port.cc",
+        "src/butil/strings/sys_string_conversions_posix.cc",
     ],
     "//conditions:default": [
         "src/butil/file_util_linux.cc",
@@ -225,7 +226,7 @@ BUTIL_SRCS = [
     ],
 })
 
-objc_library(
+cc_library(
     name = "macos_lib",
     hdrs = [
         "src/butil/atomicops.h",
@@ -240,14 +241,11 @@ objc_library(
         "src/butil/debug/debugger.h",
         "src/butil/debug/leak_annotations.h",
         "src/butil/file_descriptor_posix.h",
-        "src/butil/file_util.h",
         "src/butil/files/file.h",
         "src/butil/files/file_path.h",
         "src/butil/files/scoped_file.h",
         "src/butil/lazy_instance.h",
         "src/butil/logging.h",
-        "src/butil/mac/bundle_locations.h",
-        "src/butil/mac/foundation_util.h",
         "src/butil/mac/scoped_cftyperef.h",
         "src/butil/mac/scoped_typeref.h",
         "src/butil/macros.h",
@@ -274,15 +272,11 @@ objc_library(
         "src/butil/type_traits.h",
         ":config_h",
     ],
-    enable_modules = True,
     includes = ["src/"],
-    non_arc_srcs = [
-        "src/butil/mac/bundle_locations.mm",
-        "src/butil/mac/foundation_util.mm",
-        "src/butil/file_util_mac.mm",
-        "src/butil/threading/platform_thread_mac.mm",
-        "src/butil/strings/sys_string_conversions_mac.mm",
-    ],
+    # Note that .mm is not allowed in cc_binary.
+    srcs = [
+        "src/butil/threading/platform_thread_mac.cc",
+     ],
     tags = ["manual"],
     deps = [
         "@com_github_gflags_gflags//:gflags",
diff --git src/butil/file_util_posix.cc src/butil/file_util_posix.cc
index 3e83336..b482c6c 100644
--- src/butil/file_util_posix.cc
+++ src/butil/file_util_posix.cc
@@ -22,8 +22,6 @@
 #include <unistd.h>
 
 #if defined(OS_MACOSX)
-#include <AvailabilityMacros.h>
-#include "butil/mac/foundation_util.h"
 #elif !defined(OS_CHROMEOS) && defined(USE_GLIB)
 #include <glib.h>  // for g_get_home_dir()
 #endif
@@ -130,10 +128,6 @@ bool VerifySpecificPathControlledByUser(const FilePath& path,
 }
 
 std::string TempFileName() {
-#if defined(OS_MACOSX)
-  return StringPrintf(".%s.XXXXXX", butil::mac::BaseBundleID());
-#endif
-
 #if defined(GOOGLE_CHROME_BUILD)
   return std::string(".com.google.Chrome.XXXXXX");
 #else
@@ -436,8 +430,6 @@ bool SetPosixFilePermissions(const FilePath& path,
   return true;
 }
 
-#if !defined(OS_MACOSX)
-// This is implemented in file_util_mac.mm for Mac.
 bool GetTempDir(FilePath* path) {
   const char* tmp = getenv("TMPDIR");
   if (tmp) {
@@ -447,7 +439,6 @@ bool GetTempDir(FilePath* path) {
   }
   return true;
 }
-#endif  // !defined(OS_MACOSX)
 
 #if !defined(OS_MACOSX)  // Mac implementation is in file_util_mac.mm.
 FilePath GetHomeDir() {
@@ -878,8 +869,6 @@ bool MoveUnsafe(const FilePath& from_path, const FilePath& to_path) {
   return true;
 }
 
-#if !defined(OS_MACOSX)
-// Mac has its own implementation, this is for all other Posix systems.
 bool CopyFileUnsafe(const FilePath& from_path, const FilePath& to_path) {
   ThreadRestrictions::AssertIOAllowed();
   int infile = HANDLE_EINTR(open(from_path.value().c_str(), O_RDONLY));
@@ -926,7 +915,6 @@ bool CopyFileUnsafe(const FilePath& from_path, const FilePath& to_path) {
 
   return result;
 }
-#endif  // !defined(OS_MACOSX)
 
 }  // namespace internal
 }  // namespace butil
diff --git src/butil/threading/platform_thread_mac.cc src/butil/threading/platform_thread_mac.cc
new file mode 100644
index 0000000..13ab1b2
--- /dev/null
+++ src/butil/threading/platform_thread_mac.cc
@@ -0,0 +1,220 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "butil/threading/platform_thread.h"
+
+//#import <Foundation/Foundation.h>
+#include <mach/mach.h>
+#include <mach/mach_time.h>
+#include <mach/thread_policy.h>
+#include <sys/resource.h>
+
+#include <algorithm>
+
+#include "butil/lazy_instance.h"
+#include "butil/logging.h"
+#include "butil/threading/thread_id_name_manager.h"
+//#include "butil/tracked_objects.h"
+
+namespace butil {
+
+// If Cocoa is to be used on more than one thread, it must know that the
+// application is multithreaded.  Since it's possible to enter Cocoa code
+// from threads created by pthread_thread_create, Cocoa won't necessarily
+// be aware that the application is multithreaded.  Spawning an NSThread is
+// enough to get Cocoa to set up for multithreaded operation, so this is done
+// if necessary before pthread_thread_create spawns any threads.
+//
+// http://developer.apple.com/documentation/CocoConceptual/Multithreading/CreatingThreads/chapter_4_section_4.html
+void InitThreading() {
+#if 0
+  static bool multithreaded = [NSThread isMultiThreaded];
+  if (!multithreaded) {
+    // [NSObject class] is idempotent.
+    [NSThread detachNewThreadSelector:@selector(class)
+                             toTarget:[NSObject class]
+                           withObject:nil];
+    multithreaded = true;
+
+    DCHECK([NSThread isMultiThreaded]);
+  }
+#endif
+}
+
+// static
+void PlatformThread::SetName(const char* name) {
+  ThreadIdNameManager::GetInstance()->SetName(CurrentId(), name);
+  // TODO: add tracked_objects related headers
+  //tracked_objects::ThreadData::InitializeThreadContext(name);
+
+  // Mac OS X does not expose the length limit of the name, so
+  // hardcode it.
+  const int kMaxNameLength = 63;
+  std::string shortened_name = std::string(name).substr(0, kMaxNameLength);
+  // pthread_setname() fails (harmlessly) in the sandbox, ignore when it does.
+  // See http://crbug.com/47058
+  pthread_setname_np(shortened_name.c_str());
+}
+
+namespace {
+
+void SetPriorityNormal(mach_port_t mach_thread_id) {
+  // Make thread standard policy.
+  // Please note that this call could fail in rare cases depending
+  // on runtime conditions.
+  thread_standard_policy policy;
+  kern_return_t result =
+      thread_policy_set(mach_thread_id,
+                        THREAD_STANDARD_POLICY,
+                        reinterpret_cast<thread_policy_t>(&policy),
+                        THREAD_STANDARD_POLICY_COUNT);
+
+  if (result != KERN_SUCCESS)
+    DVLOG(1) << "Fail to call thread_policy_set";
+}
+
+// Enables time-contraint policy and priority suitable for low-latency,
+// glitch-resistant audio.
+void SetPriorityRealtimeAudio(mach_port_t mach_thread_id) {
+  // Increase thread priority to real-time.
+
+  // Please note that the thread_policy_set() calls may fail in
+  // rare cases if the kernel decides the system is under heavy load
+  // and is unable to handle boosting the thread priority.
+  // In these cases we just return early and go on with life.
+
+  // Make thread fixed priority.
+  thread_extended_policy_data_t policy;
+  policy.timeshare = 0;  // Set to 1 for a non-fixed thread.
+  kern_return_t result =
+      thread_policy_set(mach_thread_id,
+                        THREAD_EXTENDED_POLICY,
+                        reinterpret_cast<thread_policy_t>(&policy),
+                        THREAD_EXTENDED_POLICY_COUNT);
+  if (result != KERN_SUCCESS) {
+    DVLOG(1) << "Fail to call thread_policy_set";
+    return;
+  }
+
+  // Set to relatively high priority.
+  thread_precedence_policy_data_t precedence;
+  precedence.importance = 63;
+  result = thread_policy_set(mach_thread_id,
+                             THREAD_PRECEDENCE_POLICY,
+                             reinterpret_cast<thread_policy_t>(&precedence),
+                             THREAD_PRECEDENCE_POLICY_COUNT);
+  if (result != KERN_SUCCESS) {
+    DVLOG(1) << "Fail to call thread_policy_set";
+    return;
+  }
+
+  // Most important, set real-time constraints.
+
+  // Define the guaranteed and max fraction of time for the audio thread.
+  // These "duty cycle" values can range from 0 to 1.  A value of 0.5
+  // means the scheduler would give half the time to the thread.
+  // These values have empirically been found to yield good behavior.
+  // Good means that audio performance is high and other threads won't starve.
+  const double kGuaranteedAudioDutyCycle = 0.75;
+  const double kMaxAudioDutyCycle = 0.85;
+
+  // Define constants determining how much time the audio thread can
+  // use in a given time quantum.  All times are in milliseconds.
+
+  // About 128 frames @44.1KHz
+  const double kTimeQuantum = 2.9;
+
+  // Time guaranteed each quantum.
+  const double kAudioTimeNeeded = kGuaranteedAudioDutyCycle * kTimeQuantum;
+
+  // Maximum time each quantum.
+  const double kMaxTimeAllowed = kMaxAudioDutyCycle * kTimeQuantum;
+
+  // Get the conversion factor from milliseconds to absolute time
+  // which is what the time-constraints call needs.
+  mach_timebase_info_data_t tb_info;
+  mach_timebase_info(&tb_info);
+  double ms_to_abs_time =
+      (static_cast<double>(tb_info.denom) / tb_info.numer) * 1000000;
+
+  thread_time_constraint_policy_data_t time_constraints;
+  time_constraints.period = kTimeQuantum * ms_to_abs_time;
+  time_constraints.computation = kAudioTimeNeeded * ms_to_abs_time;
+  time_constraints.constraint = kMaxTimeAllowed * ms_to_abs_time;
+  time_constraints.preemptible = 0;
+
+  result =
+      thread_policy_set(mach_thread_id,
+                        THREAD_TIME_CONSTRAINT_POLICY,
+                        reinterpret_cast<thread_policy_t>(&time_constraints),
+                        THREAD_TIME_CONSTRAINT_POLICY_COUNT);
+  if (result != KERN_SUCCESS) {
+    DVLOG(1) << "Fail to call thread_policy_set";
+  }
+  return;
+}
+
+}  // anonymous namespace
+
+// static
+void PlatformThread::SetThreadPriority(PlatformThreadHandle handle,
+                                       ThreadPriority priority) {
+  // Convert from pthread_t to mach thread identifier.
+  mach_port_t mach_thread_id = pthread_mach_thread_np(handle.handle_);
+
+  switch (priority) {
+    case kThreadPriority_Normal:
+      SetPriorityNormal(mach_thread_id);
+      break;
+    case kThreadPriority_RealtimeAudio:
+      SetPriorityRealtimeAudio(mach_thread_id);
+      break;
+    default:
+      NOTREACHED() << "Unknown priority.";
+      break;
+  }
+}
+
+size_t GetDefaultThreadStackSize(const pthread_attr_t& attributes) {
+#if defined(OS_IOS)
+  return 0;
+#else
+  // The Mac OS X default for a pthread stack size is 512kB.
+  // Libc-594.1.4/pthreads/pthread.c's pthread_attr_init uses
+  // DEFAULT_STACK_SIZE for this purpose.
+  //
+  // 512kB isn't quite generous enough for some deeply recursive threads that
+  // otherwise request the default stack size by specifying 0. Here, adopt
+  // glibc's behavior as on Linux, which is to use the current stack size
+  // limit (ulimit -s) as the default stack size. See
+  // glibc-2.11.1/nptl/nptl-init.c's __pthread_initialize_minimal_internal. To
+  // avoid setting the limit below the Mac OS X default or the minimum usable
+  // stack size, these values are also considered. If any of these values
+  // can't be determined, or if stack size is unlimited (ulimit -s unlimited),
+  // stack_size is left at 0 to get the system default.
+  //
+  // Mac OS X normally only applies ulimit -s to the main thread stack. On
+  // contemporary OS X and Linux systems alike, this value is generally 8MB
+  // or in that neighborhood.
+  size_t default_stack_size = 0;
+  struct rlimit stack_rlimit;
+  if (pthread_attr_getstacksize(&attributes, &default_stack_size) == 0 &&
+      getrlimit(RLIMIT_STACK, &stack_rlimit) == 0 &&
+      stack_rlimit.rlim_cur != RLIM_INFINITY) {
+    default_stack_size =
+        std::max(std::max(default_stack_size,
+                          static_cast<size_t>(PTHREAD_STACK_MIN)),
+                 static_cast<size_t>(stack_rlimit.rlim_cur));
+  }
+  return default_stack_size;
+#endif
+}
+
+void InitOnThread() {
+}
+
+void TerminateOnThread() {
+}
+
+}  // namespace butil
